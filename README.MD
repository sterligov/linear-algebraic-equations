# Стерлигов Денис 26.02.2016 

Решение системы линейных алгебраических уравнений вида Ax=B методом отражений.
A - матрица размера n*n
x, B - вектора размерности n

/*--------------------------------------------------------------------------------------------------------------------------------*/

1. Алгоритм:

1. Находим вектор x_1 = (a_1 - ||a_1||*e_1) / ||a_1 - ||a_1||*e_1||
Где a_1 - первый столбец матрицы А, e=(1,0...0) - вектор,  || || - евклидова норма
2. Находим матрицу отражений U = I - 2*x*x_T
Где x_T - транспонированный вектор x. I - единичная матрица.
3. Умножаем матрицу U на нашу систему слева: U*Ax = U*b
Получим матрицу вида:  
||a_1|| c_1_2 ... c_1_n
0	  a_2_2 ... a_2_n
0 ............................
0 ............................
...............................
0 .....................a_n_n
И вектор B:
b_1'
b_2'
.....
b_n'

Применим теперь этот алгоритм к подматрице:
a_2_2' ... a_2_n'
......................
......................
......................
a_n_2' ... 2_n_n'
При этом остальные элементы матрицы А останутся неизменными.

И к вектору B':
b_2'
b_3'
......
b_n'

Будем применять этот алгоритм итерационно n-1 раз.
В результате получим треугольную матрицу вида:
||a_1|| c_1_2 ... c_1_n
0        ||a_1'|| ... c_2_n
................................
0 0 0 0 0 0 0 0 ||a_n'||

Если на i-ой итерации окажется, что ||a_i' - ||a_i'||*e|| = 0, то пропускаем эту итерацию, элемент отражать не нужно.

Полученная система решается обратным ходом Гаусса.

Вырожденный случай:
Если после преобразования один из диагональных элементов матрицы А равен нулю, то вся строка нулевая и матрица вырождена.
В этом случае последние r компонент вектора X пологаем равными нулю. Где r - количество нулевых строк.
Если какая-то строка матрицы А нулевая, а соответствующий элемент вектора B ненулевой, то решений нет.

Если система переопределена, тогда производим перестановку нулевых столбцов в конец матрицы, при этом запоминая какие столбцы переставлены.
Получается матрица вида A = (A'|0), где A' - ненулевая подматрица, 0 - нулевая подматрица. К получившейся матрице применяем алгоритм.
В конце переставляем компоненты X, в соответствии с изначальное матрицей.
Такое трансформирование матрицы делается для работы алгоритма, если не производить эти манипуляции, 
то алгоритм будет не применим к некоторым вырожденным матрицам, например к такой:
0 a
0 0



/*--------------------------------------------------------------------------------------------------------------------------------*/

2. Погрешность при решении:
Для уменьшения погрешности при суммировании используется алгоритм Кэхэна, псевдокод:
function KahanSum(input)
    var sum = 0.0
    var c = 0.0          
    for i = 1 to Len(input) do
        y = input[i] - c   
        t = sum + y       
        c = (t - sum) - y  
        sum = t            
    return sum
Погрешность оценивается с помощью нормы вектора невязки ||Ax' - B||, где x' - полученное решение. 
      
/*--------------------------------------------------------------------------------------------------------------------------------*/


3. Синтаксис командной строки:

Синтаксис запуска:
,/lss [Входной файл] [Выходной файл] [Опции]

Опции:
  -d	печать отладочных сообщений [по умолчанию отключено]
  -e	печать ошибок [по умолчанию отключено] 
  -p   печать матрицы [по умолчанию отключено]
  -t	печать времени выполнения в секундах и временных тактах процессора [по умолчанию отключено]
  -h, -?	печать справки*
  -с   печать нормы вектора невязки
  -dm считывание матрицы в диагональном виде[по умолчанию отключено]

* - если задано несколько параметров, один из которых h, то все параметры кроме h игнорируются.
 
Если входной и выходной файлы не заданы, то по умолчанию используются файлы lss_28_10_in.txt - входной и lss_28_10_out.txt - выходной.
Если задан только один файл, то он считается входным.
Имя файла не может начинаться с '-'.

/*--------------------------------------------------------------------------------------------------------------------------------*/

4. Дополнительная память:
Для алгоритма понадобится вектор из элементов типа double размерности n для хранения результата умножения x_T*A.
И вектор из элементов типа int размерности n+1, для хранения результатов перестановки столбцов(для переопределенной системы, описанной в пункте 1)
В первых n*sizeof(double) байтах будет хранится результат умножения x_T*A, во вторых (n+1)*sizeof(int) - номера переставленных столбцов и их количество.
Таким образом требуется n*sizeof(double) + (n+1)*sizeof(int) байт памяти.

/*--------------------------------------------------------------------------------------------------------------------------------*/

5. Константы:
DBL_EPSILON = 1e-10 константа, если число по модулю меньше DBL_EPSILON, то пологаем его равным нулю.

/*--------------------------------------------------------------------------------------------------------------------------------*/

6.Ошибки:

NOT_EXIST = -8, решений не существует
PARAMETR_ERR = -7 - ошибка в параметре переданном через консоль - неизвестный параметр
N_ERR = -6 - ошибка размера матрицы
PRINT_ERR = -5 - ошибка печати в файл
READ_ERR = -4 - ошибка считывания с файла
ALLOC_ERR = -3 - ошибка выделения памяти
CLOSE_ERR = -2 - ошибка закрытия файла
OPEN_ERR = -1 - ошибка открытия файла

/*--------------------------------------------------------------------------------------------------------------------------------*/

Везде ниже полагается: 
A - матрица коэффициентов 
B - столбец свободных членов
X - содержит решение системы, если оно существует
Если решения не существует X содержит некоторые промежуточные вычисления, которые не будут записаны в файл
n - количество уравнений в системе

/*--------------------------------------------------------------------------------------------------------------------------------*/

7. Описание итерфейсных функций:

int main(int argc, char **argv);
Возвращает 0 в случае удачного завершения, иначе код ошибки

void error_processing(int err) - функция печати ошибок.
err - код ошибки.
По коду ошибки функция определяет что вывести на экран, и завершает работу программы с номером этой ошибки.


int cmd_parse(int argc, char **argv, char *p, char *t, char *h, char *c,
	char **inFileName, char **outFileName) -  функция разбирающая параметры командной строки
argc - количество переданных параметров командной строки
argv - массив имен параметров
p - флаг печати матрицы
t - флаг печати времени исполнения
h - флаг печати справки
c - флаг печати погрешности
inFileName - имя входной файла
outFileName - имя выходного файла 
В случае неизвестного параметра возвращает номер этого параметра.
Если неизвестных параметров несколько, возвращает номер последнего неизвестного параметра.
В случае успешного завершения возвращает 0.

int strcmp(char *s1, char *s2); - сравнивает строки s1 и s2
Возвращает 0 если они равны и 1 если не равны.


void print_help() - печать справки

/*--------------------------------------------------------------------------------------------------------------------------------*/

8. Описание функций вычислительного модуля:


int lss_28_10(int n, double *A, double *B, double *X, double *tmp) - функция решения
tmp - массив дополнительной памяти
Возвращает 0 в случае решения системы, 
1 в случаи если решения не существует, 


size_t lss_memsize_28_10(int n) - функция определяющая размер дополнительной памяти
n - количество уравнений в системе.


int get_X(double *A, double *X, int n, int diag) - функция вычисляющая вектор a_i - ||a_i||*e / ||a_i - ||a_i||*e||
diag - номер диагонального элемента с которого начинаетя вектор-столбец a_i, размерность этого вектора n - diag
Для экономии памяти, в этой функции вектор X будем использовать для промежуточных вычислений.
Вектор, полученный в результате работы функции будет записан в Х.
Возвращает -1 если отражение производить не нужно, т.е. a_i - ||a_i||*e = 0.
0 - если всё завершилось удачно.


void get_A(double *A, double *tmp, double *X, int diag, int n) - перемножение матриц U и A
diag - номер текущего диагонального элемента, вокруг которого происходит отражение.
Вектор x_T умножается на подматрицу A'(начинающуюся с элемента с индексами diag_diag) 
матрицы A и записывается в tmp, затем из подматрицы A' вычитается матрица 2*x_T*A*x = 2*tmp*x


void get_B(double *B, double *B, double *X, int diag, int n) - перемножение U и B
diag - номер текущего диагонального элемента, вокруг которого происходит отражение.
Вектор x_T умножается на подвектор B' вектора B, получается число const. Затем из B' вычитаем 2*x_T*B*x=2*const*x


int gauss(double *A, double *B, double *X, int n) - обратный ход методом Гаусса
Если матрица вырождена пологаем r последних компонент равными нулям, где r - количество нулевых строк.
Если какая строка матрицы А нулевая, а соответствующий элемент вектора B ненулевой, то решений нет.
Если матрица была переопределенной, то в конце меняем элементы вектора X в соответствии с изначальной матрицей.
Вовращает 0 если решение существует и 1 если решения не существует.


int alloc_mem(double **tmp, size_t n) - функция выделение памяти
n - количество требуемых байт
tmp - указатель на выделяемую память
Выделяет память размера n байт, указатель на начало которой помещается в tmp.
Возвращает 0 в случаи успешного выделения и -3 в случаи неудачного выделения пямяти.


int read_from_file(int *n, double **A, double **B, const char *fileName) - считывание с файла fileName
Количество уравнений в системе считывается в n.
Выделяется память для А и матрица коэффициентов считывается в массив А. 
Выделяется память для В и вектор свободных коэффициентов считывается в массив B. 
Возвращает код ошибки или 0 в случае успешного считывания.


int write_in_file(int n, double *X, const char *fileName, char sol) - запись ответа в файл outFilename.
Параметр sol = 1, если решения не существует и sol = 0, если решение существует, в
зависимости от этого параметра в файл записывается либо 0(если решения не существует), либо вектор решения Х.
Возвращает 0 в случае успешной записи и код ошибки в случаи ошибки.


void print_matrix(double *A, int n, int m) - печать матрицы размера n*m


void transform_matrix(int n, double *A, double *tmp); - перестройка матрицы к виду A'|0, если это требуется, т.е. если система переопределена.


int is_null_column(int n, double *A, int col); - проверим нулевой ли столбец
сol - индекс проверяемого столбца


void swap_column(int n, double *A, int i, int j); - Меняет местами столбцы с номерами i и j


int find_column(int n, double *A, int curColumn); - Поиск ненулевого стобца
curColumn - текущей нулевой столбец который мы хотим поставить в конец.
Поиск ненулевого столбца будет идти от n-1 столбца до curColumn
Возвращает номер столбца если такой найден и -1 если не найден.


double check_solution(double *A, double *B, double *X, int n); - вычисление нормы вектора невязки
X - полученное решение
A - исходная матрица коэффициентов
B - исходный вектор
Вовращает норму вектора невязки


int copy_matrix(int n, double *A, double *B, double **initA, double **initB) 
Копирование матрицы А и вектора В в матрицу initA и вектора initB.
Эта функция требуется для вычисления вектора невязки, т.к. в процессе вычислений А и В изменятся.

/*--------------------------------------------------------------------------------------------------------------------------------*/









